#!/usr/bin/env ruby

require 'optparse'
require 'English'

@green = "\033[0;32m"
@red = "\033[0;31m"
@white = "\033[0m"
@dir = "#{Dir.home}/.enote"
@notes_dir = "#{@dir}/notes"
@conf = "#{@dir}/config"
@default_editor = File.read(@conf)[/(?<=editor=)(.*)/]

def has_notes
   !Dir["#{@notes_dir}/*"].entries.empty?
end

def list
  if has_notes
    system("ls #{@notes_dir}")
  else
    puts "No notes created yet"
  end
end

def edit(name)
  cmd = "#{@default_editor} #{@notes_dir}/#{name}"
  system(cmd)
  unless $CHILD_STATUS.exitstatus == 0
    puts "#{@red}An error occurred when running: #{cmd}. Is #{@default_editor} installed?#{@white}"
    exit 1
  end
end

def remove(name)
  path = "#{@notes_dir}/#{name}"
  if File.exists? path
    system("rm #{path}")
    puts "#{@green}Removed note #{name}#{@white}"
  end
end

def set_editor(editor)
  text = File.read(@conf).gsub(/editor=.*/,"editor=#{editor}")
  File.open(@conf, "w") {|f| f.puts text }
  puts "#{@green}Editor changed to #{editor}#{@white}"
end

op = OptionParser.new
op.banner = "Manage notes in favourite command line text editor.

Usage: #{File.basename($PROGRAM_NAME)} [option]...[note]..."
op.on("-l", "--list", "list all notes") {list}
op.on("-e", "--edit NOTE", "edit or create new note called NOTE") {|n| edit n}
op.on("-r", "--remove NOTE", "remove note called NOTE") {|n| remove n}
op.on("-s", "--set-editor VALUE", "set default editor to VALUE (e.g. vim)") {|v| set_editor v}
op.on("-h", "--help", "Prints this help") {puts op; exit}

if Dir.exists? @dir
  begin
    ARGV << '-h' if ARGV.empty?
    (ARGV[0][0] != "-") ? (edit ARGV[0]) : op.parse!
  rescue OptionParser::MissingArgument => e
    puts "#{@red}An error occurred: #{e.message}.#{@white}"
    puts
    puts op
    exit 2
  end
else
  puts "#{@red}ENote is not installed for current user. Install by running './install'#{@white}"
end
